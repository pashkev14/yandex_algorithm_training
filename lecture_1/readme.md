# Тема 1: жадный алгоритм и задача о рюкзаке

## [А. Каждому по компьютеру (решено полностью)](A.py)
### Текст задачи
В новом учебном году во Дворец Творчества Юных для занятий в компьютерных классах пришли учащиеся, которые были разбиты на N групп. В i-й группе оказалось X_i человек. Тут же перед директором встала серьезная проблема: как распределить группы по аудиториям. Во дворце имеется M >= N аудиторий, в j-й аудитории имеется Y_j компьютеров. Для занятий необходимо, чтобы у каждого учащегося был компьютер и еще один компьютер был у преподавателя. Переносить компьютеры из одной аудитории в другую запрещается. Помогите директору!

Напишите программу для поиска максимального количества групп, которое удастся одновременно распределить по аудиториям, чтобы всем учащимся в каждой группе хватило компьютеров, и при этом остался хотя бы один для учителя.

Формат ввода

На первой строке входного файла расположены числа N и M (1 <= N <= M <= 1000). На второй строке расположено N чисел - X_1 ... X_N (1 <= X_i <= 1000 для всех i). На третьей строке расположено M чисел - Y_1 ... Y_M (1 <= Y_j <= 1000 для всех j).

Формат вывода

Выведите на первой строке число P — количество групп, которое удастся распределить по аудиториям. На второй строке выведите распределение групп по аудиториям — N чисел, i-е число должно соответствовать номеру аудитории, в которой должна заниматься i-я группа. Нумерация как групп, так и аудиторий, начинается с 1. Если i-я группа осталась без аудитории, i-е число должно быть равно 0. Если допустимых распределений несколько, выведите любое из них.

Примеры

Ввод:

1 1

1

2

Вывод:

1

1

Единственная группа с номером 1 из 1 человека сможет занять единственную аудиторию с номером 1 вместимостью 2 человека (1 + 1 <= 2)

Ответ:

1 группа

1-ая группа получит аудиторию номер 1

___

Ввод:

1 1

1

1

Вывод:

0

0

Единственная группа с номером 1 из 1 человека не сможет занять единственную аудиторию с номером 1 вместимостью 1 человек (1 + 1 > 1)

Ответ:

0 групп

1-ая группа не занимает аудиторию, поэтому 0

### Предлагаемое решение
Использовать жадный алгоритм: так как одна группа занимает строго одну аудиторию, будет оптимально, если группа с наибольшим числом займет самую большую аудиторию, а дальше вторая самая большая группа займет вторую самую большую аудиторию и так далее...

Что нужно сделать:

1) Каждой группе присвоить аудиторию №0 (то есть каждая группа изначально не имеет свою аудиторию)
2) Отсортировать группы по невозрастанию их размера (при этом сохранить их исходные порядковые номера)
3) Отсортировать аудитории по невозрастанию их вместимости (при этом сохранить их исходные порядковые номера)
4) Завести "курсор" для списка аудитории и счетчик кол-ва распределенных групп
5) Прогнаться по списку групп:

   - Если размер i-ой группы + 1 <= вместимость аудитории по курсору, то присваиваем группе номер аудитории по курсору, сдвигаем курсор вправо на одну позицию и инкрементируем счетчик
   - Если i-ая группа не влезает в аудиторию по курсору, то, соответственно, она не влезет и во все остальные аудитории по списку (так как у нас сортировка по невозрастанию), следовательно, эту группу придется оставить без аудитории, счетчик не инкрементируем, курсор не сдвигаем, переходим к следующей группе
6) Выводим счетчик
7) Сортируем список групп по их порядковым номерам
8) Выводим присвоенные номера аудиторий у каждой группы в списке

## [B. Ни больше ни меньше (решено полностью)](B.py)
### Текст задачи
Дан массив целых положительных чисел a длины n. Разбейте его на минимально возможное количество отрезков, чтобы каждое число было не меньше длины отрезка, которому оно принадлежит. Длиной отрезка считается количество чисел в нём.

Разбиение массива на отрезки считается корректным, если каждый элемент принадлежит ровно одному отрезку.

Формат ввода

Первая строка содержит одно целое число t (1 <= t <= 1000) - количество наборов тестовых данных. Затем следуют t наборов тестовых данных.

Первая строка набора тестовых данных содержит одно целое число n (1 <= n <= 10^5) - длину массива.

Следующая строка содержит n целых чисел a_1, a_2, ..., a_n (1 <= a_i <= n для всех i) - массив a.

Гарантируется, что сумма n по всем наборам тестовых данных не превосходит 2 * 10^5.

Формат вывода

Для каждого набора тестовых данных в первой строке выведите число k - количество отрезков в вашем разбиении.

Затем в следующей строке выведите k чисел len_1, len_2, ..., len_k (1 <= len_i <= n для всех i, сумма всех len = n) - длины отрезков в порядке слева направо.

Пример

Ввод:

3

5

1 3 3 3 2

16

1 9 8 7 6 7 8 9 9 9 9 9 9 9 9 9

7

7 2 3 4 3 2 7

Вывод:

3

1 2 2

3

1 6 9

3

2 3 2

### Предлагаемое решение

Использовать жадный алгоритм: поскольку разбиение происходит слева направо, логично, что меньше всего разбиений будет, когда мы захватываем в одно разбиение как можно больше чисел

Что нужно сделать:

1) Считать t
2) Завести t пустых списков, в которые будем заносить длины разбиений
3) t раз обработать поступающие наборы:
   
   - Считать n
   - Считать массив чисел длины n
   - Завести "локальный минимум" с начальным значением n (имеем право так сделать, поскольку все числа в массиве не превышают n)
   - Завести счетчик текущей длины
   - Прогнать массив:
     
     - Инкрементировать длину
     - Если очередное число меньше локального минимума, то это число становится новым локальным минимумом
     - Если внезапно текущая длина превысила локальный минимум, то это означает, что мы считали лишнее значение, нужно его отсечь: занести в список разбиений длину на 1 меньше, сделать длину равной 1 (как будто мы начали новое разбиение), сделать локальным минимумом текущее значение (поскольку оно уже вошло в новое разбиение)
     - Если текущая длина равна локальному минимуму, то просто заносим длину в список разбиений, обнуляем текущую длину и локальный минимум, поскольку мы еще не считали новое значение
   
   - Если сумма длин разбиений не равна n (а она должна быть!), значит, последнее разбиение еще не было занесено в список, занести его

4) Для каждого списка разбиений вывести его длину и длины его разбиений